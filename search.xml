<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[消息队列MQ]]></title>
    <url>%2F2018%2F03%2F08%2Fmq%2F</url>
    <content type="text"><![CDATA[介绍MQ算是我们日常开发过程中使用最多最频繁之一的中间件了。这里对MQ的特点和使用场景做下简单介绍总结。 什么是MQ消息队列（Message Queue）简称MQ，是一种跨进程的通信机制，常用于上下游“逻辑解耦+物理解耦”的消息通信服务。上下游的关系可以理解为发布-订阅模式。 MQ的优势和不足优势： 1）同步调用改异步，提高性能 2）解决业务的相互依赖，解耦 3）可以控制下游服务的执行效率，达到缓冲流量、削峰填谷的目的 MQ的不足： 1）上游无法知道下游的执行结果。这一点是最重要的，因此很多需要实时调用返回执行结果的业务场景，是无法使用MQ的。 2）系统更复杂，多了一个MQ组件 3）消息传递路径更长，延时会增加 4）消息可靠性和重复性互为矛盾，消息不丢不重难以同时保证 MQ的应用场景MQ主要应用于异步解耦、削峰填谷等，在一些上游服务不需要实时获取下游服务的执行结果的场景中频繁使用。 应用一：高并发下的缓冲流量、削峰填谷比如秒杀抢购等高并发写库场景，如果在接口程序中实时写库操作，可能会对数据库造成极大压力而导致崩溃，优化方案之一，就是对提交的数据校验成功后将其推到MQ，再调取下游写库服务，以此来控制写库频率。值得注意的是，这套流程还需要注意写库服务失败后处理，比如写库失败直接扔回queue还是触发另外的机制等。 应用二：上游不关心下游执行结果，异步调用，提高性能这个也是在我们接口开发中使用比较多的场景。因为接口的性能都会要求比较高，业务很复杂的情况下，很多不需要在实时返回接口的业务程序，一般都会拆离出去，通过MQ异步调用。 单线程同步调用时：上游-&gt;下游1-&gt;下游2-&gt;下游3 通过MQ异步调用： 【场景1：发帖】比如58同城招聘用户发布帖子后，招聘业务要奖励58豆，房产用户发布帖子后，房产业务要送2个置顶，二手用户发布帖子后，二手业务要修改用户统计数据。 应用三：解决任务依赖，解耦举个栗子，互联网公司经常在凌晨进行一些数据统计任务，这些任务之间有一定的依赖关系，比如： 1）task3需要使用task2的输出作为输入 2）task2需要使用task1的输出作为输入 这样的话，tast1, task2, task3之间就有任务依赖关系，必须task1先执行，再task2执行，载task3执行。 MQ解耦： 【场景2：下订单】通常电商的订单系统跟仓库系统等都是分离的，用户下订单之后，无需关注后续仓库物流打包等操作，通过MQ解耦 我司的push系统也是采用这种方式来实现的。值得注意的是这套方案，会导致系统格外复杂，代码分散，维护的成本非常高。 应用四：上游关注执行结果，但执行时间很长 有时候上游需要关注执行结果，但执行结果时间很长（典型的是调用离线处理，或者跨公网调用），也经常使用回调网关+MQ来解耦。 举个栗子，微信支付，跨公网调用微信的接口，执行时间会比较长，但调用方又非常关注执行结果，此时一般怎么玩呢？ 一般采用“回调网关+MQ”方案来解耦： 1）调用方直接跨公网调用微信接口 2）微信返回调用成功，此时并不代表返回成功 3）微信执行完成后，回调统一网关 4）网关将返回结果通知MQ 5）请求方收到结果通知 这里需要注意的是，不应该由回调网关来调用上游来通知结果，如果是这样的话，每次新增调用方，回调网关都需要修改代码，仍然会反向依赖，使用回调网关+MQ的方案，新增任何对微信支付的调用，都不需要修改代码啦。 总结：MQ是异步解耦，削峰填谷的利器。]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL规范]]></title>
    <url>%2F2017%2F11%2F05%2Fmysql-specification%2F</url>
    <content type="text"><![CDATA[一、基础规范表存储引擎必须使用InnoDB解读：线上 DB 统一使用 InnoDB 存储引擎，线下统计类从库也可用Ｍyisam 引擎 表字符集默认使用utf8mb4，而不是utf8解读：（1）通用，无乱码风险，汉字3字节，英文1字节（2）utf8mb4是utf8的超集，emoji表情以及部分不常见汉字在utf8下会表现为乱码 禁止使用存储过程，视图，触发器，Event解读：（1）对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层（2）调试，排错，迁移都比较困难，扩展性较差（3）高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能” 禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统，数据库中存储路径解读：大文件和照片存储在文件系统，数据库里存URI所有表、所有字段都需要加注释，推荐采用英文标点，避免出现乱码。状态类字段需説明每个状态的意义： 0:fail 1:pass 2:pending单表数据行数建议控制在 2000W－3000W 以内，单表数据量控制在5G以下（大于这个数请前期设计的时候分表）禁止在线上环境做数据库压力测试测试，开发，线上数据库环境必须隔离 二、命名规范库名、表名使用大驼峰（类似UserGroupRecord），列名必须用小写，采用下划线分隔库名、表名、字段名禁止使用 MySQL 保留字库名，表名，列名必须见名知义，长度不要超过32字符解读：tmp，wushan谁TM知道这些库是干嘛的禁止使用拼音，除了没有英文名的（比如：哈药 hayao），其它都用英文禁止表名后面跟日期：tablename2015(建表之前与业务沟通，线上建表必须与业务结合起来，避免按自己的意思去单独建表)临时库、表名必须以 tmp 为前缀，并以日期为后缀。例如tmp_lama_20150427。（临时表用完后必须删除）库备份必须以bak为前缀，以日期为后缀从库必须以-s为后缀备库必须以-ss为后缀只允许使用内网域名，而不是ip连接数据库线上环境、开发环境、测试环境数据库内网域名遵循命名规范业务名称：xxx线上环境：dj.xxx.db开发环境：dj.xxx.rdb测试环境：dj.xxx.tdb从库在名称后加-s标识，备库在名称后加-ss标识线上从库：dj.xxx-s.db线上备库：dj.xxx-sss.db 三、表设计规范表必须有主键，推荐使用UNSIGNED整数为主键解读：1）主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用2）主键要选择较短的数据类型，Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率3）潜在坑：删除无主键的表，如果是row模式的主从架构，从库会挂住单实例表个数必须控制在500个以内（一个数据库最多500张表）单表分表个数必须控制在1024个以内禁止使用外键，如果要保证完整性，应由应用程式实现解读：外键使得表之间相互耦合，影响update/delete等SQL性能，十分影响sql性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈，大数据高并发业务场景数据库使用以性能优先 建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据解读：具体参加《如何实施数据库垂直拆分》 若需分表，表名后缀使用十进制数，数字建议从0开始(table_1，table_2，table_3)按日期时间分表需符合 YYYY[MM][DD][HH]格式。（例如 2013071601。年份必须用 4 位数字表示。例如按日散表 user_20110209、按月散表 user_201102） 四、列设计规范根据业务区分使用tinyint/smallint/int/bigint，分别会占用1/2/4/8字节INT 类型固定占 4 字节存储，例如 INT(4)仅代表显示字符宽度为 4 位，不代表存储长度根据业务区分使用char/varchar解读：（1）字段长度固定，或者长度近似的业务场景，适合使用char，能够减少碎片，查询性能高（2）字段长度相差较大，或者更新较少的业务场景，适合使用varchar，能够减少空间 使用尽可能小的 VARCHAR 字段。VARCHAR(N)中的 N 表示字符数而非字节数根据业务区分使用datetime/timestamp解读：前者占用5个字节，后者占用4个字节，存储年使用YEAR，存储日期使用DATE，存储时间使用datetime 必须把字段定义为NOT NULL并设默认值解读：（1）NULL的列使用索引，索引统计，值都更加复杂，MySQL更难优化（2）NULL这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多（3）NULL需要更多的存储空间（3）NULL只能采用IS NULL或者IS NOT NULL，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录 建议使用 UNSIGNED 存储非负数值使用 VARBINARY 存储大小写敏感的变长字符串或二进制内容使用INT UNSIGNED存储IPv4，不要用char(15)使用varchar(20)存储手机号，不要使用整数解读：（1）牵扯到国家代号，可能出现+/-/()等字符，例如+86（2）手机号不会用来做数学运算（3）varchar可以模糊查询，例如like ‘138%’ 使用TINYINT来代替ENUM解读：ENUM增加新值要进行DDL操作。用 DECIMAL 代替 FLOAT 和 DOUBLE 存储精确浮点数，例如支付相关数据尽可能不使用 TEXT、BLOB 类型解读：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能单表字段个数控制在 30 以下 五、索引规范唯一索引使用uniq_[字段名]来命名非唯一索引使用idx_[字段名]来命名索引名必须全部使用小写表必须有主键，推荐使用 UNSIGNED 自增列作为主键单张表索引数量建议控制在5个以内解读：（1）互联网高并发业务，太多索引会影响写性能（2）生成执行计划时，如果索引太多，会降低性能，并可能导致MySQL选择不到最优索引（3）异常复杂的查询需求，可以选择ES等更为适合的方式存储 组合索引字段数不建议超过5个解读：如果5个字段还不能极大缩小row范围，八成是设计有问题 不建议在频繁更新的字段上建立索引解读：更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能 不在低基数，区分度不高的列上建立索引。例如“性别”，不能有效过滤数据，性能与全表扫描非必要不要进行JOIN查询，如果要进行JOIN查询，被JOIN的字段必须类型相同，并建立索引解读：踩过因为JOIN字段类型不一致，而导致全表扫描的坑么？ 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)禁止冗余索引禁止重复索引禁止使用外键 六、SQL规范禁止使用select ，只获取必要字段解读：（1）select 会增加cpu/io/内存/带宽的消耗（2）指定字段能有效利用索引覆盖（3）指定字段查询，在表结构变更时，能保证对应用程序无影响 insert必须指定字段，禁止使用insert into T values()解读：指定字段插入，在表结构变更时，能保证对应用程序无影响 禁止隐式转换。数值类型禁止加引号；字符串类型必须加引号解读：隐式类型转换会使索引失效，导致全表扫描 禁止在where条件列使用函数或者表达式解读：导致不能命中索引，全表扫描 禁止负向查询NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等以及%开头的模糊查询解读：导致不能命中索引，全表扫描 禁止大表JOIN和子查询。必要时推荐用 JOIN 代替子查询解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能 同一个字段上的OR必须改写问IN，IN的值必须少于50个解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？ 应用程序必须捕获SQL异常使用 EXPLAIN 判断 SQL 语句是否合理使用索引force–index（对于单独条件如果走不了索引，强要强制指定索引）拆分复杂 SQL 为多个小 SQL，避免大事务减少与数据库交互次数，尽量采用批量 SQL 语句获取大量数据时，建议分批次获取数据，每次获取数据少于 2000 条，结果集应小于 1MMyisam 引擎统计行数用 COUNT(*)。InnoDB 引擎统计行数用 COUNT(主键 id）建议使用合理的分页方式以提高分页效率解读：方便定位线上问题 七、行为规范禁止使用应用程序配置文件内的帐号手工访问线上数据库禁止非DBA对线上数据库进行写操作，修改线上数据需要提交工单，由DBA执行，提交的SQL语句必须经过测试分配非DBA以只读帐号，必须通过VPN+跳板机访问授权的从库开发、测试、线上环境隔离禁止有 super 权限、DDL、DCL 权限的应用程序账号存在表结构变更必须通知 DBA 进行审核，大表 DDL 操作提前一天发送需求，避免大于 5000 万行记录的表进行 DDL 操作，除开特殊情况不要在 MySQL 数据库中存放业务逻辑master 上面，除了业务需要实时查询的 select，其它的 select 必须放在slave 上面统计相关，后台查询相关的 select，禁止放在线上从库上面。这种类型的统一放在线下的统计从库上面 参考文章：https://cloud.tencent.com/developer/article/1004367https://mp.weixin.qq.com/s/YfCORbcCX1hymXBCrZbAZghttps://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959906&amp;idx=1&amp;sn=2cbdc66cfb5b53cf4327a1e0d18d9b4a&amp;chksm=bd2d07be8a5a8ea86dc3c04eced3f411ee5ec207f73d317245e1fefea1628feb037ad71531bc&amp;scene=21#wechat_redirecthttps://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959910&amp;idx=1&amp;sn=6b6853b70dbbe6d689a12a4a60b84d8b&amp;chksm=bd2d07ba8a5a8eac6783bac951dba345d865d875538755fe665a5daaf142efe670e2c02b7c71&amp;scene=21#wechat_redirect]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识swoole]]></title>
    <url>%2F2017%2F07%2F07%2Fswoole%2F</url>
    <content type="text"><![CDATA[Server运行流程图 进程/线程结构图 创建TCP Server 示例代码12345678910111213141516171819202122//创建Server对象，监听 127.0.0.1:9501端口$serv = new swoole_server(&quot;127.0.0.1&quot;, 9501); //监听连接进入事件$serv-&gt;on(&apos;connect&apos;, function ($serv, $fd) &#123; echo &quot;Client: Connect.\n&quot;;&#125;);//服务器可以同时被成千上万个客户端连接，$fd就是客户端连接的唯一标识符//监听数据接收事件$serv-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) &#123; $serv-&gt;send($fd, &quot;Server: &quot;.$data);&#125;);//监听连接关闭事件$serv-&gt;on(&apos;close&apos;, function ($serv, $fd) &#123; echo &quot;Client: Close.\n&quot;;&#125;);//启动服务器$serv-&gt;start(); ==swoole_server只能用于php-cli环境，否则会抛出致命错误。请勿在使用swoole_server之前调用其他异步IO的API，否则将无法创建swoole_server。== swoole_server是异步服务器，支持TCP、UDP、UnixSocket 3种协议，通过监听事件的方式来执行程序的。使用者无需关注底层实现细节，仅需要设置网络事件的回调函数即可。如当有新的TCP连接进入时会执行onConnect事件回调，当某个连接向服务器发送数据时会回调onReceive函数。客户端主动断开连接，会触发onClose事件回调。 构建Server对象1$serv = new swoole_server(&quot;127.0.0.1&quot;, 9501, SWOOLE_BASE, SWOOLE_SOCK_TCP); $mode运行的模式，swoole提供了3种运行模式，默认为多进程模式 $sock_type指定socket的类型，支持TCP/UDP、TCP6/UDP6、UnixSock Stream/Dgram 6种设置运行时参数 123456789$serv-&gt;set(array( &apos;reactor_num&apos; =&gt; 2, //通过此参数来调节poll线程的数量，以充分利用多核。reactor_num和writer_num默认设置为CPU核数 &apos;worker_num&apos; =&gt; 4, //设置启动的worker进程数量。swoole采用固定worker进程的模式。PHP代码中是全异步非阻塞，worker_num配置为CPU核数的1-4倍即可。如果是同步阻塞，worker_num配置为100或者更高 &apos;max_conn&apos; =&gt; 10000, //最大tcp连接 &apos;max_request&apos; =&gt; 50, //此参数表示worker进程在处理完n次请求后结束运行。manager会重新创建一个worker进程。此选项用来防止worker进程内存溢出。 &apos;daemonize&apos; =&gt; true, //守护进程化 &apos;backlog&apos; =&gt; 128, //Listen队列长度.此参数将决定最多同时有多少个待accept的连接，swoole本身accept效率是很高的，基本上不会出现大量排队情况。 &apos;log_file&apos; =&gt; &apos;/data/log/swoole.log&apos; //日志)); 属性列表123456$serv-&gt;setting; //set()函数所设置的参数会保存到$setting属性上。$serv-&gt;manager_pid; //管理进程的PID，通过向管理进程发送SIGUSR1信号可实现柔性重启$serv-&gt;master_pid; //主进程的PID，通过向主进程发送SIGTERM信号可安全关闭服务器$serv-&gt;worker_id; //得到当前Worker进程的编号，包括Task进程。$serv-&gt;worker_pid; //得到当前Worker进程的操作系统进程ID$serv-&gt;connections; //当前服务器的客户端连接，可使用foreach遍历所有连接 ==工作进程重启后worker_id的值是不变的== 注册事件回调函数12345$serv-&gt;on(&apos;Connect&apos;, &apos;my_onConnect&apos;);$serv-&gt;on(&apos;Receive&apos;, &apos;my_onReceive&apos;);$serv-&gt;on(&apos;Close&apos;, &apos;my_onClose&apos;);$serv-&gt;on(&apos;Task&apos;, &apos;my_onTask&apos;);//处理异步任务$serv-&gt;on(&apos;Finish&apos;, &apos;my_onFinish&apos;);//返回处理异步任务的结果 PHP中可以使用4种回调函数的风格,我个人比较倾向函数式。 编程须知： 在异步IO的程序中，不得使用sleep/usleep/time_sleep_until/time_nanosleep onReceive事件中执行了sleep函数，server在100秒内无法再收到任何客户端请求。 在swoole程序中禁止使用exit/die，如果PHP代码中有exit/die，当前工作的Worker进程、Task进程、User进程、以及swoole_process进程会立即退出。 建议使用try/catch的方式替换exit/die，实现中断执行跳出PHP函数调用栈。 Client同步阻塞客户端123456789101112131415161718192021$client = new swoole_client(SWOOLE_SOCK_TCP);//连接到服务器if (!$client-&gt;connect(&apos;127.0.0.1&apos;, 9501, 0.5))&#123; die(&quot;connect failed.&quot;);&#125;//向服务器发送数据if (!$client-&gt;send(&quot;hello world&quot;))&#123; die(&quot;send failed.&quot;);&#125;//从服务器接收数据$data = $client-&gt;recv();if (!$data)&#123; die(&quot;recv failed.&quot;);&#125;echo $data;//关闭连接$client-&gt;close(); 这个客户端是同步阻塞的，connect/send/recv 会等待IO完成后再返回。同步阻塞操作并不消耗CPU资源，IO操作未完成当前进程会自动转入sleep模式，当IO完成后操作系统会唤醒当前进程，继续向下执行代码。 异步非阻塞客户端123456789101112131415161718192021222324$client = new swoole_client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_ASYNC);//注册连接成功回调$client-&gt;on(&quot;connect&quot;, function($cli) &#123; $cli-&gt;send(&quot;hello world\n&quot;);&#125;);//注册数据接收回调$client-&gt;on(&quot;receive&quot;, function($cli, $data)&#123; echo &quot;Received: &quot;.$data.&quot;\n&quot;;&#125;);//注册连接失败回调$client-&gt;on(&quot;error&quot;, function($cli)&#123; echo &quot;Connect failed\n&quot;;&#125;);//注册连接关闭回调$client-&gt;on(&quot;close&quot;, function($cli)&#123; echo &quot;Connection close\n&quot;;&#125;);//发起连接$client-&gt;connect(&apos;127.0.0.1&apos;, 9501, 0.5); ==异步客户端只能用于cli环境== 异步客户端是非阻塞的。可以用于编写高并发的程序。 异步客户端需要设置回调函数，4个事件回调必须设置onConnect、onError、onReceive、onClose。分别在客户端连接成功、连接失败、收到数据、连接关闭时触发。同步阻塞客户端一定不要使用on方法]]></content>
      <categories>
        <category>swoole</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的事务隔离级别]]></title>
    <url>%2F2017%2F07%2F05%2Fmysql-transaction-level%2F</url>
    <content type="text"><![CDATA[数据库的事务隔离等级read uncommited不可避免脏读。 read commited可避免脏读，不可避免不可重复读。 repeated readmysql InnoDB默认级别的默认事务等级，不可以避免幻读。 serializable完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。 脏读:是指当前事务可以查看到别的事务未提交的数据（重点未提交）。 例如，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。 提交读，可以有效避免脏读。 不可重复读：是指一个事务内两次相同的查询却返回了不同结果集。 在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问并修改该同一数据。造成第一个事务的两次读数据的结果不一样。 解决办法：如果只有在修改事务完全提交之后才可以读取数据。例如mysql行锁。 幻读：是指事务B以插入或删除行等方式来修改事务A查询搜索的结果集。 例如事务A查询表中是否存在id=1的数据，如不存在往表里则插入数据。而事务B则在事务A查询后插入前，往表里插入了一条id=1的数据，事务A之前的查询结果就无效，像出现幻觉一样。 这种情况在高并发情况下会出现，mysql的默认事务等级可重复读，不能避免，只有最高等级的SERIALIZABLE_READ可以保证不出现幻读的问题。例如表锁。 隔离级别 脏读（Dirty Read） 不可重复读（NonRepeatable Read） 幻读（Phantom Read） 未提交读（Read uncommitted） 可能 可能 可能 已提交读（Read committed） 不可能 可能 可能 可重复读（Repeatable read） 不可能 不可能 可能 可串行化（Serializable ） 不可能 不可能 不可能]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引]]></title>
    <url>%2F2017%2F04%2F17%2Fmysql-index%2F</url>
    <content type="text"><![CDATA[关于MySQL索引（《高性能MySQL》阅读有感）B-Tree索引当我们讨论索引的时候，没有特别指明类型，多半是指的B-Tree索引。InnoDB引擎使用的B+Tree结构，按照原数据格式（MyISAM前缀压缩）进行存储，根据主键引用被索引的行（MyISAM根据物理位置）。 B-树意味着所有值都是按照顺序存储的，并且每个叶子页到根节点的距离相同。因为存储引擎不再需要进行全表扫描，只需要从索引根节点搜索，所以可以加快数据访问速度 局部性原理和磁盘预读由于磁盘的存取速度与内存之间鸿沟,为了提高效率,要尽量减少磁盘I/O.磁盘往往不是严格按需读取，而是每次都会预读,磁盘读取完需要的数据,会顺序向后读一定长度的数据放入内存。而这样做的理论依据是计算机科学中著名的局部性原理：12当一个数据被用到时，其附近的数据也通常会马上被使用程序运行期间所需要的数据通常比较集中 由于磁盘顺序读取的效率很高(不需要寻道时间，只需很少的旋转时间)，因此对于具有局部性的程序来说，预读可以提高I/O效率.预读的长度一般为页(page)的整倍数。 什么是索引索引可以理解为目录，字典的搜索表。索引的本质就是排序。每建一个索引就相当于将增加一个包含主键和索引列的索引表，表中数据按照索引顺序排序。因为索引字段不宜过多，索引也不能滥用，否则会影响写表的性能。 聚簇索引和非聚簇索引 聚簇：索引的叶子节点指向数据 innodb 非聚簇：索引的叶子节点指向引用 myisam 对于innodb引擎，如果没有primary key，在用unique key作主键，如果没有unique，则mysql会生成一个rowid作主键 索引类型 主键索引 primary key 唯一索引 unique index 普通索引 index 全文索引 fulltext index 索引的使用原则前缀索引区分度区分度指字段在数据库的不重复比。区分度越大，索引效果越明显。在区分度较小的字段上新建索引，基本无效，还会增加大量的索引文件，得不偿失。 最左匹配原则MySQL会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配。缀索引在排序 order by 和分组 group by 操作的时候无法使用。 模糊查询前模糊是无法使用索引的，类似where c like ‘%a’。而like ‘a%’ 等价于 where c &gt;= ‘a’ and c &lt; ‘b’ 不能使用索引的场景 前模糊：例 like “%N” 隐式转换：例如name字段是varchar，而sql中where name=1而不是name=’1’ 函数运算不要在查询语句中加函数运算，否则索引失效。 不要滥用索引多余的索引会降低读写性能。即使满足了上述原则，mysql还是可能会弃用索引，因为有些查询即使使用索引，也会出现大量的随机io，相对于从数据记录中的顺序io开销更大。 EXPLAIN表扫描Handler_read_rnd_next 的值高则意味着查询运行低效，存在大量的表扫描，应该建立索引补救。 索引优化索引碎片与维护在数据表长期的更改过程中，索引文件和数据文件都会产生空洞，形成碎片。修复表的过程十分耗费资源，可以用比较长的周期修复表。1234//清理方法alert table xxx engine innodb; //或optimize table xxx;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch 安装配置]]></title>
    <url>%2F2017%2F04%2F04%2Felk%2F</url>
    <content type="text"><![CDATA[Elasticsearch安装配置安装java81234//查看java版本java -version//安装javayum -y install java-1.8.0 下载Elasticsearch123456789//下载wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.4.2.zip//校验sha1sum elasticsearch-5.4.2.zip//解压sudo unzip -n elasticsearch-5.4.2.zip -d /usr/local////usr/local/elasticsearch-5.4.2 即为$ES_HOME//启动/usr/local/elasticsearch-5.4.2/bin/elasticsearch 常见错误1OpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x0000000085330000, 2060255232, 0) failed; error=&apos;Cannot allocate memory&apos; (errno=12) 错误原因：elasticsearch5.0默认分配jvm空间大小为2g 解决方案：修改jvm空间分配vim /usr/local/elasticsearch-5.4.2/config/jvm.options-Xms2g-Xmx2g修改为-Xms512m-Xmx512m 1can not run elasticsearch as root 错误原因：不能以root启动 解决方案：添加elasticsearch的用户并切换elasticsearch文件夹所属用户 12345678910111213141516171819202122groupadd esuseradd es -g es -p eschown -R es:es /usr/local/elasticsearch-5.4.2/sudo chown -R seclogin:users /usr/local/elasticsearch-5.4.2/max file descriptors [65535] for elasticsearch process is too low, increase to at least [65536]vim /etc/security/limits.conf //修改或者添加如下* hard nofile 65536* soft nofile 65536max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]vim /etc/sysctl.conf//修改或者添加如下vm.max_map_count=262144//修改后sysctl -a，不起效就sysctl -p 1Failed to obtain node lock 解决方案：需要重启elasticsearch 12345//停止elasticsearchps -ef | grep elastickill -9 xxx//切换到 es用户再重新执行（seclogin用户不需要）su es -c /usr/local/elasticsearch-5.4.2/bin/elasticsearch 外部访问需以下配置12345678910111213141516vim /usr/local/elasticsearch-5.4.2/config/elasticsearch.ymlnetwork.host: 172.17.6.219 #本服务器ip//centos7以下需要修改iptablesvim /etc/sysconfig/iptables-A INPUT -p tcp -m state --state NEW -m tcp --dport 9200 -j ACCEPT-A INPUT -p udp -m state --state NEW -m udp --dport 9200 -j ACCEPTservice iptables restart//centos7需要修改firewall（如果没有防火墙就不用管了）firewall-cmd --permanent --add-port=9200/tcpfirewall-cmd --reloadfirewall-cmd --state//后台启动elasticsearch/usr/local/elasticsearch-5.4.2/bin/elasticsearch -d Elasticsearch测试及使用1234567891011121314151617181920212223242526272829303132333435363738//查看集群健康状态curl &apos;http://172.16.9.192:9200/_cat/health?v&apos; (dev)curl &apos;http://10.10.1.71:9200/_cat/health?v&apos; (test)curl &apos;http://10.1.2.56:9200/_cat/health?v&apos; (online)//查看 Elasticsearch 的基本信息curl &apos;http://172.16.9.192:9200/?pretty&apos; (dev)curl &apos;http://10.10.1.71:9200/?pretty&apos; (test)curl &apos;http://10.1.2.56:9200/?pretty&apos; (online)//列出所有索引curl &apos;http://172.16.9.192:9200/_cat/indices?v&apos; (dev)curl &apos;http://10.10.1.71:9200/_cat/indices?v&apos; (test)curl &apos;http://10.1.2.56:9200/_cat/indices?v&apos; (online)//添加一个名叫 test的索引（可理解为数据库）curl -XPUT &apos;http://172.16.9.192:9200/test?pretty&apos;curl -XPUT &apos;http://10.1.2.56:9200/test?pretty&apos;//查看索引curl &apos;http://101.200.42.161:9200/test?pretty&apos;//创建一个类型curl -XPUT &apos;http://101.200.42.161:9200/test/_mapping/article?pretty&apos; -d &apos;&#123; &quot;properties&quot;: &#123; &quot;id&quot;: &#123; &quot;type&quot;: &quot;integer&quot;, &quot;index&quot;: &quot;not_analyzed&quot; &#125;, &quot;subject&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;analyzer&quot;: &quot;standard&quot; &#125;, &quot;content&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;analyzer&quot;: &quot;standard&quot; &#125;, &quot;author&quot;: &#123; &quot;type&quot;: &quot;string&quot;, &quot;index&quot;: &quot;not_analyzed&quot; &#125; &#125;&#125;&apos; 测试数据导入12wget https://github.com/bly2k/files/blob/master/accounts.zip?raw=truecurl -XPOST &apos;http://101.200.42.161::9200/bank/account/_bulk?pretty&apos; --data-binary @accounts.json Elasticsearch-PHP 配置https://www.elastic.co/guide/en/elasticsearch/client/php-api/5.0/_configuration.html 备注：elasticsearch默认最大查询数量是一万，test和online环境将最大查询数量提到了十万，设置命令：curl -XPUT http://10.1.2.56:9200/contentplatform/_settings -d ‘{ “index” : { “max_result_window” : 100000}}’]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Composer简介]]></title>
    <url>%2F2016%2F11%2F15%2Fcomposer%2F</url>
    <content type="text"><![CDATA[Composer官方文档 简介Composer 是 PHP 的一个依赖管理工具。Composer不是一个包管理器，但它在每个项目的基础上进行管理，在你项目的某个目录中（例如vendor）进行安装。默认情况下它不会在全局安装任何东西。因此，这仅仅是一个依赖管理。用过linux编译安装以后就很好理解了。 Linux安装 下载可执行文件1curl -sS https://getcomposer.org/installer | php 注：需要curl工具和php-openssl、zlib扩展 全局访问1mv composer.phar /usr/local/bin/composer 然后就可以在任何地方都能运行 composer 命令啦 使用声明依赖关系比如你需要一个库来做日志记录,决定使用 monolog。为了将它添加到你的项目中，你所需要做的就是创建一个 composer.json 文件，其中描述了项目的依赖关系。12345&#123; &quot;require&quot;: &#123; &quot;monolog/monolog&quot;: &quot;1.2.*&quot; &#125;&#125; require 需要一个 包名称 （例如 monolog/monolog） 映射到 包版本 （例如 1.0.*） 的对象 安装依赖包 - install1php composer.phar install 如果你进行了全局安装，可使用下面的命令代替：1composer install 接着前面的例子，这将会找到 monolog/monolog 的最新版本，并将它下载到 vendor 目录。 这是一个惯例把第三方的代码到一个指定的目录 vendor。如果是 monolog 将会创建 vendor/monolog/monolog 目录。install 命令将创建一个 composer.lock 文件到你项目的根目录中。 composer.lock - 锁文件在安装依赖后，Composer 将把安装时确切的版本号列表写入 composer.lock 文件。这将锁定改项目的特定版本。 注意：请提交你应用程序的 composer.lock （包括 composer.json）到你的版本库中。这是非常重要的，因为 install 命令将会检查锁文件是否存在，如果存在，它将下载指定的版本（忽略 composer.json 文件中的定义）。这意味着，任何人建立项目都将下载与指定版本完全相同的依赖。 更新 - update12php composer.phar updateor composer update 这将获取最新匹配的版本（根据你的 composer.json 文件）并将新版本更新进锁文件。如果只想安装或更新一个依赖，你可以白名单它们：1php composer.phar update monolog/monolog [...] 自动加载你只需要将下面这行代码添加到你项目的引导文件中：1require &apos;vendor/autoload.php&apos;; 便可以加载 Composer 下载的库中所有的类文件。]]></content>
      <categories>
        <category>PHP</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>PHP包管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类和接口的区别]]></title>
    <url>%2F2015%2F11%2F17%2Finterface%2F</url>
    <content type="text"><![CDATA[面试经常碰到的问题，这里简单写下自己的理解； 核心区别设计思想不同,使用动机不同. 抽象类：对一类事物的抽象，接口：对某一行为动作的抽象。 比如男人，女人两个类，我们可以抽象成一个更高级的类人或者生物。一个类只能继承一个抽象类（例如你不能既为生物又为非生物），而一个类又可以实现多个接口，比如吃饭接口，开车接口，啪啪啪接口等。 两者相同点 都不能直接实例化 都可以有抽象方法 抽象类要被子类继承，接口要被子类实现 抽象类和接口的抽象方法都必须全部被子类实现，如果子类不能实现，那么子类必须是抽象类 抽象类和接口中的方法都要被实现，所以抽象方法不能是静态的static，也不能是私有的private。 两者不同点 核心区别：设计思想和使用动机不同：抽象类是对事物类别的抽象，接口是对行为功能的抽象。当你关注事物的本质的时候，请用抽象类；当你关注一种操作的时候，用接口。 接口的方法只能声明不能实现，抽象类的方法既能声明也能实现。换句话说就是，接口只能有抽象方法，抽象类既可以有抽象方法，也可以有非抽象方法。所以说接口是设计的结果，抽象类是重构的结果。 抽象类可以有一些非抽象方法的存在，这些方法被称为默认实现。如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。 类只能继承一个类，但是可以实现多个接口。 抽象类的修饰符可以是public，protected，接口只能是public 总结因为高级语言一个类只能继承一个父类，即你在设计这个类的时候必须要抽象出所有这个类的子类所具有的共同属性和方法,但是类（接口）却可以继承多个接口，因此每个接口你只需要将特定的动作方法抽象到这个接口即可。也就是说，接口的设计具有更大的可扩展性，而抽象类的设计必须十分谨慎。。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub搭建个人Blog]]></title>
    <url>%2F2015%2F10%2F06%2Fhexo%2F</url>
    <content type="text"><![CDATA[Hexo简介Hexo是一款基于Node.js的静态博客框架，可以方便的生成静态网页托管在GitHub和Heroku上。参见：Github地址 安装Git/Node.js依赖本地安装git、node.js。这个不赘述了。1234//git安装检测git --version//npm安装检测npm -v 安装Hexo12345678910//安装npm install hexo -g//初始化网站hexo init blog //新建bloghexo new test//生成静态文件hexo g//开启本地服务器hexo s 打开浏览器输入地址： localhost:4000 就能看到页面了。 更多相关命令参见：https://hexo.io/zh-cn/ 推送GitHubGitHub创建个人仓库 仓库名必须为：github账号名.github.io，固定写法，别问为啥。 本地生成ssh密钥文件：1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 然后直接三个回车即可，默认不需要设置密码。然后vi ~/.ssh/id_rsa.pub文件，将内容全部复制 打开GitHub/Setting/SSH keys页面,new SSH Key标题随意，内容复制进入保存，输入 ssh git@github.com ：https://pic3.zhimg.com/80/v2-da481ffa686410becd4186c656b4ebd6_hd.jpg如上则说明成功 修改站点配置文件打开blog根目录下的_config.yml，翻到最后修改为：1234deploy: type: gitrepo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .gitbranch: master 然后输入1hexo g -d //生成并推送 然后在浏览器输入xxxx.github.io就可访问了。 更换主题主题传送门 我使用的NEXT主题：github地址 NEXT主题中文配置文档 NEXT主题去掉footer字样 绑定域名]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
