
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PHP设计模式 - 何笙的博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="类型和六大原则设计模式的类型共有 23 种设计模式。这些模式可以分为三大类：

创建型模式（Creational Patterns）- 这些设计模式关注如何创建对象。这使得程序在判断针对某个给定实例,"> 
    <meta name="author" content="何笙"> 
    <link rel="alternative" href="atom.xml" title="何笙的博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">何笙的博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">PHP设计模式</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">PHP设计模式</h1>
        <div class="stuff">
            <span>四月 25, 2019</span>
            

        </div>
        <div class="content markdown">
            <h3 id="类型和六大原则"><a href="#类型和六大原则" class="headerlink" title="类型和六大原则"></a>类型和六大原则</h3><h4 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h4><p>共有 23 种设计模式。这些模式可以分为三大类：</p>
<ul>
<li><p><strong>创建型模式（Creational Patterns）- 这些设计模式关注如何创建对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</strong></p>
<ul>
<li>单例、多例、对象池</li>
<li>抽象工厂</li>
<li>工厂方法、静态工厂</li>
<li>建造者</li>
<li>原型模式</li>
</ul>
</li>
<li><p><strong>结构型模式（Structural Patterns）- 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</strong></p>
<ul>
<li>适配器</li>
<li>桥接</li>
<li>装饰</li>
<li>组合</li>
<li>代理</li>
<li>外观</li>
<li>享元</li>
</ul>
</li>
<li><p><strong>行为型模式（Behavioral Patterns）- 这些设计模式特别关注对象之间的交互和职责分配。</strong></p>
<ul>
<li>责任链</li>
<li>命令</li>
<li>解释器</li>
<li>迭代器</li>
<li>中介者</li>
<li>备忘录</li>
<li>观察者</li>
<li>状态</li>
<li>策略</li>
<li>模板</li>
<li>访问者</li>
</ul>
</li>
</ul>
<h4 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h4><ol>
<li><p><strong>单一职责原则（Single Responsibility Principle，简称SRP ）</strong></p>
<ul>
<li><strong>核心思想：</strong> 一个类只负责一项职责；应该有且仅有一个原因引起类的变更</li>
</ul>
</li>
<li><p><strong>开放封闭原则（Open Close Principle,简称OCP）</strong></p>
<ul>
<li><strong>核心思想：</strong> 对扩展开放，对修改关闭</li>
</ul>
</li>
<li><p><strong>里氏替换原则（Liskov Substitution Principle,简称LSP）</strong></p>
<ul>
<li><strong>核心思想：</strong> 在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类</li>
<li>增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。</li>
</ul>
</li>
<li><p><strong>依赖倒置原则（Dependence Inversion Principle,简称DIP）</strong></p>
<ul>
<li><strong>核心思想：</strong> 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象</li>
<li>通俗讲就是通过抽象，来实现各个类或模块的松耦合。也就是面向接口编程。</li>
</ul>
</li>
<li><p><strong>接口隔离原则（Interface Segregation Principle,简称ISP）</strong></p>
<ul>
<li><strong>核心思想：</strong> 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</li>
<li>建立单一接口，为依赖类建立专用的接口。接口要细化，避免肥接口，但是也要适度，接口过小，也会造成接口数量过多，使设计复杂化。</li>
</ul>
</li>
<li><p><strong>迪米特法则，或最少知道原则（Law of Demeter,简称LOD）</strong></p>
</li>
</ol>
<ul>
<li><strong>核心思想：</strong> 类间减耦，一个类应当尽量避免与其他类的相互依赖。</li>
<li>高内聚，低耦合。</li>
</ul>
<h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><h4 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h4><p>意图： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>主要解决： 一个全局使用的类频繁地创建与销毁<br>解决方法：构造函数是私有，不允许直接new实例化；判断是否已经有这个单例，如果有则返回，如果没有则创建。<br>应用场景：I/O与数据库等连接</p>
<p>示例代码：<br>Singleton.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static $instance = null;</span><br><span class="line"></span><br><span class="line">    private function __construct() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private function __clone() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //防止被反序列化</span><br><span class="line">    private function __wakeup() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static function getInstance() &#123;</span><br><span class="line">        if (is_null(self::$instance)) &#123;</span><br><span class="line">            self::$instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$instance = Singleton::getInstance();</span><br></pre></td></tr></table></figure></p>
<h4 id="多例模式（Muliton）"><a href="#多例模式（Muliton）" class="headerlink" title="多例模式（Muliton）"></a>多例模式（Muliton）</h4><p>多例模式和单例模式类似，但可以返回多个实例。</p>
<p>示例代码：<br>Multition.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Multition &#123;</span><br><span class="line"></span><br><span class="line">    private static $instances = array();</span><br><span class="line"></span><br><span class="line">    const INSTANCE = array(&apos;instance1&apos;,  &apos;instance2&apos;);</span><br><span class="line"></span><br><span class="line">    private function __construct() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private function __clone() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //防止被反序列化</span><br><span class="line">    private function __wakeup() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static function getInstance($instanceName) &#123;</span><br><span class="line">        if (!in_array($instanceName, self::INSTANCE)) &#123;</span><br><span class="line">            throw new Exception(&apos;error&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!array_key_exists($instanceName, self::$instances)) &#123;</span><br><span class="line">            self::$instances[$instanceName] = new self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return self::$instances[$instanceName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="对象池模式（Pool）"><a href="#对象池模式（Pool）" class="headerlink" title="对象池模式（Pool）"></a>对象池模式（Pool）</h4><p>对象池模式是多例模式的一个变种，对象池是一组已经初始化过且可以直接使用的对象集合，用户在使用对象时可以从对象池中获取对象，对其进行操作处理，并在不需要时归还给对象池而非销毁它。<br>若对象初始化、实例化的代价高，且需要经常实例化，但每次实例化的数量较少的情况下，使用对象池可以获得显著的性能提升。如果要实例化的对象较小，不需要多少资源开销，就没有必要使用对象池模式了，这非但不会提升性能，反而浪费内存空间，甚至降低性能。<br>常见的使用对象池模式的技术包括线程池、数据库连接池、任务队列池、图片资源对象池等。</p>
<p>示例代码：<br>Pool.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace DesignPatterns\Creational\Pool;</span><br><span class="line"></span><br><span class="line">class Pool</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    private $instances = array();</span><br><span class="line">    private $class;</span><br><span class="line"></span><br><span class="line">    public function __construct($class)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;class = $class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function get()</span><br><span class="line">    &#123;</span><br><span class="line">        if (count($this-&gt;instances) &gt; 0) &#123;</span><br><span class="line">            return array_pop($this-&gt;instances);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new $this-&gt;class();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function dispose($instance)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;instances[] = $instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Processor.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace DesignPatterns\Creational\Pool;</span><br><span class="line"></span><br><span class="line">class Processor</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    private $pool;</span><br><span class="line">    private $processing = 0;</span><br><span class="line">    private $maxProcesses = 3;</span><br><span class="line">    private $waitingQueue = [];</span><br><span class="line"></span><br><span class="line">    public function __construct(Pool $pool)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;pool = $pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function process($image)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;processing++ &lt; $this-&gt;maxProcesses) &#123;</span><br><span class="line">            $this-&gt;createWorker($image);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $this-&gt;pushToWaitingQueue($image);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function createWorker($image)</span><br><span class="line">    &#123;</span><br><span class="line">        $worker = $this-&gt;pool-&gt;get();</span><br><span class="line">        $worker-&gt;run($image, array($this, &apos;processDone&apos;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function processDone($worker)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;processing--;</span><br><span class="line">        $this-&gt;pool-&gt;dispose($worker);</span><br><span class="line"></span><br><span class="line">        if (count($this-&gt;waitingQueue) &gt; 0) &#123;</span><br><span class="line">            $this-&gt;createWorker($this-&gt;popFromWaitingQueue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function pushToWaitingQueue($image)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;waitingQueue[] = $image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function popFromWaitingQueue()</span><br><span class="line">    &#123;</span><br><span class="line">        return array_pop($this-&gt;waitingQueue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Worker.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace DesignPatterns\Creational\Pool;</span><br><span class="line"></span><br><span class="line">class Worker</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        // let&apos;s say that constuctor does really expensive work...</span><br><span class="line">        // for example creates &quot;thread&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function run($image, array $callback)</span><br><span class="line">    &#123;</span><br><span class="line">        // do something with $image...</span><br><span class="line">        // and when it&apos;s done, execute callback</span><br><span class="line">        call_user_func($callback, $this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#### 简单工厂模式(Simple Factory)</span><br><span class="line">不属于23种设计模式之一。</span><br><span class="line">由三个角色组成：</span><br><span class="line">- 工厂类：生产具体产品</span><br><span class="line">- 抽象产品</span><br><span class="line">- 具体产品</span><br><span class="line"></span><br><span class="line">![image.png](https://upload-images.jianshu.io/upload_images/2281730-5804ae0ffa025909.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">示例代码：</span><br></pre></td></tr></table></figure></p>
<p>//工厂类<br>class MouseFactory {<br>    public static function createMouse($type) {<br>        switch($type) {<br>            case ‘deil’:<br>                return new DeilMouse();<br>            case ‘hp’:<br>                return new HpMouse();<br>            default:<br>                throw new Exception(‘error type’);<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">//抽象产品</span><br><span class="line">abstract class Mouse &#123;</span><br><span class="line">    public abstract function click() &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line">class DeilMouse extends Mouse &#123;</span><br><span class="line">     public function click() &#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HpMouse extends Mouse &#123;</span><br><span class="line">     public function click() &#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式(Factory Method)"></a>工厂方法模式(Factory Method)</h4><p><img src="https://upload-images.jianshu.io/upload_images/2281730-826a5066128d643b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>它由四种角色组成：</p>
<ul>
<li>抽象工厂</li>
<li>具体工厂</li>
<li>抽象产品</li>
<li>具体产品<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//抽象工厂</span><br><span class="line">abstract class MouseFactory&#123;</span><br><span class="line">    public abstract function createMouse();</span><br><span class="line">&#125;</span><br><span class="line">//具体工厂</span><br><span class="line">class DeilFactory extends MouseFactory&#123;</span><br><span class="line">    public function createMouse() &#123;</span><br><span class="line">         return new DeilMouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HpFactory extends MouseFactory&#123;</span><br><span class="line">    public function createMouse()&#123;</span><br><span class="line">         return new HpMouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>工厂方法模式是完全符合开闭原则的。</strong>当有新产品时，只要创建并继承抽象产品；新建具体工厂继承抽象工厂；而不用修改现有任何代码。<br>缺点是当产品种类非常多时，就会出现大量的与之对应的工厂类。</p>
<h4 id="抽象工厂-Abstract-Factory"><a href="#抽象工厂-Abstract-Factory" class="headerlink" title="抽象工厂(Abstract Factory)"></a>抽象工厂(Abstract Factory)</h4><p>抽象工厂模式也就是不仅生产鼠标，同时生产键盘。<br>也就是PC厂商是个父类，有生产鼠标，生产键盘两个接口。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2281730-5d0b56f24893c3cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>在抽象工厂模式中，假设我们需要增加一个工厂</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/2281730-b94cf57e5a3c6c2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>在抽象工厂模式中，假设我们需要增加一个产品</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/2281730-0c2ddab3b79d6c95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>由上图可以看出，抽象工厂模式是不符合开闭原则的，产品族扩展非常困难，要增加一个产品，既要在抽象工厂里加代码，又要在具体工厂里面加代码。</p>
<p>####建造者模式（Builder Pattern）</p>
<blockquote>
<p>建造者模式（Builder Pattern）将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p><strong>问题引出：</strong><br>假设我们有个生产车的工厂，可以制造各种车，比如自行车、汽车、卡车等等，如果每辆车都是从头到尾按部就班地造，必然效率低下。<br><strong>解决方法：</strong><br>我们可以试着将车的组装和零部件生产分离开来：让一个类似“导演”的角色负责车子组装，而具体造什么样的车需要什么样的零部件让具体的“构造者”去实现。<br><strong>使用场景：</strong><br> 一些基本部件不会变，而其组合经常变化的时候。<br><strong>关键代码：</strong><br> 建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p>
<p>#####示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//组装类</span><br><span class="line">class Director &#123;</span><br><span class="line">    public function build(BuilderInterface $builder) &#123;</span><br><span class="line">        $builder-&gt;createVehicle();</span><br><span class="line">        $builder-&gt;addDoors();</span><br><span class="line">        $builder-&gt;addEngine();</span><br><span class="line">        $builder-&gt;addWheel();</span><br><span class="line"></span><br><span class="line">        return $builder-&gt;getVehicle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//建造者接口</span><br><span class="line">interface BuilderInterface &#123;</span><br><span class="line">    public function createVehicle();</span><br><span class="line"></span><br><span class="line">    public function addWheel();</span><br><span class="line"></span><br><span class="line">    public function addEngine();</span><br><span class="line"></span><br><span class="line">    public function addDoors();</span><br><span class="line"></span><br><span class="line">    public function getVehicle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//建造者实例</span><br><span class="line">class BikeBuilder implements BuilderInterface &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CarBuilder implements BuilderInterface &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//零件类</span><br><span class="line">class Wheel &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Doors &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Engine &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####总结：<br>建造者模式跟抽象工厂模式相比，就是多了一个“导演类”的角色，可以用来创建更加复杂的对象。抽像工厂模式是将对象的全部创建过程封装在工厂类中，而建造者模式中，建造者类一般只提供产品的各个组件的建造方法，而将建造过程交付给导演类。</p>
<h4 id="原型模式（Prototype）"><a href="#原型模式（Prototype）" class="headerlink" title="原型模式（Prototype）"></a>原型模式（Prototype）</h4><blockquote>
<p>原型模式是通过clone 方法来实现对象创建而不是使用标准的new 方式。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Prototype &#123;</span><br><span class="line">    public function __clone() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><blockquote>
<p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>
</blockquote>
<p><strong>意图：</strong> 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><strong>关键代码：</strong> 适配器继承或依赖已有的对象，实现想要的目标接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Map接口</span><br><span class="line"> */</span><br><span class="line">interface MapInterface &#123;</span><br><span class="line">    public function search(); //查找</span><br><span class="line">    public function locat(); //定位</span><br><span class="line">    public function direct(); //路线规划</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * MyMap 自定义map实现</span><br><span class="line"> */</span><br><span class="line">class MyMap implements MapInterface&#123;</span><br><span class="line">    public function search() &#123;</span><br><span class="line">        echo &quot;mymap search\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function locat() &#123;&#125;</span><br><span class="line">    public function direct() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * BaiduMap 引入扩展的第三方BaiduMap</span><br><span class="line"> */</span><br><span class="line">class BaiduMap &#123;</span><br><span class="line">    public function baiduSearch() &#123;</span><br><span class="line">        echo &quot;baidu search\n&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">    public function baiduLocat() &#123;&#125;</span><br><span class="line">    public function baiduDirect() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * GooleMap 引入扩展的第三方GoogleMap</span><br><span class="line"> */</span><br><span class="line">class GoogleMap  &#123;</span><br><span class="line">    public function googleSearch() &#123;</span><br><span class="line">        echo &quot;google search\n&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">    public function googleLocat() &#123;&#125;</span><br><span class="line">    public function googleDirect() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 适配器类</span><br><span class="line"> */</span><br><span class="line">class MapAdapter implements MapInterface &#123;</span><br><span class="line">    private $map;</span><br><span class="line"></span><br><span class="line">    public function __construct($map) &#123;</span><br><span class="line">        $this-&gt;map = $map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function search() &#123;</span><br><span class="line">        if ($this-&gt;map instanceof BaiduMap) &#123;</span><br><span class="line">            $this-&gt;map-&gt;baiduSearch();</span><br><span class="line">        &#125; elseif ($this-&gt;map instanceof GoogleMap) &#123;</span><br><span class="line">            $this-&gt;map-&gt;googleSearch();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $this-&gt;map-&gt;search();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public function locat() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public function direct() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 客户端</span><br><span class="line"> */</span><br><span class="line">class Client &#123;</span><br><span class="line">    //@var MapInterface</span><br><span class="line">    protected $map;</span><br><span class="line"></span><br><span class="line">    public function __construct(MapInterface $map) &#123;</span><br><span class="line">        $this-&gt;map = $map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function setMap(MapInterface $map) &#123;</span><br><span class="line">        $this-&gt;map = $map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function find() &#123;</span><br><span class="line">        $this-&gt;map-&gt;search();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getLocation() &#123;</span><br><span class="line">        $this-&gt;map-&gt;locat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//客户端不需要修改业务代码调用map的逻辑，只需要自行选择切换map实例就好</span><br><span class="line">$client = (new Client(new MyMap()))-&gt;find();</span><br><span class="line">$client = (new Client(new MapAdapter(new BaiduMap())))-&gt;find();</span><br></pre></td></tr></table></figure>
<h4 id="桥梁模式（Bridge）"><a href="#桥梁模式（Bridge）" class="headerlink" title="桥梁模式（Bridge）"></a>桥梁模式（Bridge）</h4><blockquote>
<p>将抽象与实现解耦，使它们都可以独立的变化。</p>
</blockquote>
<p><strong>主要解决：</strong> 桥梁模式完全是为了解决继承的缺点而提出的设计模式。在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2281730-b75e241f0de8e0a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2281730-d58ae6d4abf5d9b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bridge"></p>
<p><strong>代码示例</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//颜色接口和实现</span><br><span class="line">interface Color &#123;</span><br><span class="line">    public functino setColor() &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">class Red implements Color &#123;</span><br><span class="line">    public functino setColor() &#123;</span><br><span class="line">        return &quot;red&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Black implements Color &#123;</span><br><span class="line">    public functino setColor() &#123;</span><br><span class="line">        return &quot;black&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//图形接口和实现</span><br><span class="line">interface Shap &#123;</span><br><span class="line">    public function draw(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line">class Cirlce implements Shap &#123;</span><br><span class="line">    public function setIndex()</span><br><span class="line">        return [x, y, z] ；     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">abstract AbstractDraw &#123;</span><br><span class="line">    private $color = &apos;&apos;;</span><br><span class="line">    private $shap = [0,0,0];</span><br><span class="line">    public function setColor(interface Color)&#123;&#125;;</span><br><span class="line">    public function setShap(interface Shap)&#123;&#125;;</span><br><span class="line">    public function draw() &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">//画图</span><br><span class="line">class Draw extends AbstractDraw&#123;</span><br><span class="line">    public function setColor(interface Color)&#123;</span><br><span class="line">        $this-&gt;color = Color.setColor();</span><br><span class="line">    &#125;</span><br><span class="line">    public function setShap(interface Shap)&#123;</span><br><span class="line">        $this-&gt;shap = Shap.setIndex();</span><br><span class="line">    &#125;</span><br><span class="line">    public function draw() &#123;</span><br><span class="line">        echo $this-&gt;color. &apos;x: &apos; . $this-&gt;shap[0] . &apos;y:&apos; $this-&gt;shap[1] . &apos;z:&apos; .$this-&gt;shap[2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="装饰器模式（Decorator）"><a href="#装饰器模式（Decorator）" class="headerlink" title="装饰器模式（Decorator）"></a>装饰器模式（Decorator）</h4><blockquote>
<p>装饰器模式能够从一个对象的外部动态地给对象添加功能。</p>
</blockquote>
<p>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。使用装饰器可以动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<p><strong>关键代码：</strong><br>Component 类充当抽象角色，不应该具体实现。<br>修饰类引用和继承 Component 类，具体扩展类重写父类方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//被装饰类</span><br><span class="line">interface Renderer &#123;</span><br><span class="line">    public function renderData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WebRender implements Renderer &#123;</span><br><span class="line">    protected $data;</span><br><span class="line"></span><br><span class="line">    public function __construct($data) &#123;</span><br><span class="line">        $this-&gt;data = $data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function renderData() &#123;</span><br><span class="line">        return $this-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在在不改动原有的类的基础上，增加renderXml和renderJson的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//实现Renderer的抽象装饰类</span><br><span class="line">abstract class Decorator implements Renderer &#123;</span><br><span class="line">    protected $derectedRender;</span><br><span class="line"></span><br><span class="line">    public function __construct(Renderer $derectedRender) &#123;</span><br><span class="line">        $this-&gt;derectedRenderd = $derectedRender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //public function renderData() &#123;</span><br><span class="line">      //  $this-&gt;derectedRenderd-&gt;renderData() ;</span><br><span class="line">    //&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实体装饰类</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * RenderInXml类</span><br><span class="line"> */</span><br><span class="line">class RenderInXml extends Decorator &#123;</span><br><span class="line">    public function renderData()</span><br><span class="line">    &#123;</span><br><span class="line">        $output = $this-&gt;derectedRenderd-&gt;renderData() ;</span><br><span class="line"></span><br><span class="line">        // do some fancy conversion to xml from array ...</span><br><span class="line"></span><br><span class="line">        $doc = new \DOMDocument();</span><br><span class="line"></span><br><span class="line">        foreach ($output as $key =&gt; $val) &#123;</span><br><span class="line">            $doc-&gt;appendChild($doc-&gt;createElement($key, $val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $doc-&gt;saveXML();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * RenderInJson类</span><br><span class="line"> */</span><br><span class="line">class RenderInJson extends Decorator &#123;</span><br><span class="line">    public function renderData()</span><br><span class="line">    &#123;</span><br><span class="line">        $output = $this-&gt;derectedRenderd-&gt;renderData() ;</span><br><span class="line"></span><br><span class="line">        return json_encode($output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//client </span><br><span class="line">$service = new RenderInXml(new WebRender(array(&apos;foo&apos; =&gt; &apos;bar&apos;)));</span><br></pre></td></tr></table></figure>
<h4 id="门面模式（Facade）又称外观模式"><a href="#门面模式（Facade）又称外观模式" class="headerlink" title="门面模式（Facade）又称外观模式"></a>门面模式（Facade）又称外观模式</h4><p>为客户端提供了一个客户端可以访问系统的接口。降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。</p>
<p><strong>何时使用：</strong> 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。</p>
<p><strong>应用实例：</strong> 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。</p>
<p>门面模式与建造者模式类似，不过Builder 倾向于解决创建复杂的对象的问题，对象有复杂的内部结构，我们可以根据变化灵活的组合。而Facade 倾向于解决内部系统各个类之间复杂逻辑的问题，降低客户端使用系统的难度。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2281730-c1764137ee3cb4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2281730-813e3bb71d6ba2a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//系统角色类</span><br><span class="line">class Register &#123;</span><br><span class="line">    public static function register() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Pay &#123;</span><br><span class="line">    public static function pay() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Medication &#123;</span><br><span class="line">    public static function getMedication() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//门面角色类</span><br><span class="line">class Facade &#123;</span><br><span class="line">    public function buyMedition() &#123;</span><br><span class="line">          Register::register();</span><br><span class="line">          Pay::pay() ;</span><br><span class="line">          Medication::getMedication();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p>组合模式（Composite Pattern）又叫做部分-整体模式，用于将对象组合成树形结构以表示“部分-整体”的层次关系。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>常见使用场景：如树形菜单、文件夹菜单、部门组织架构图等。</p>
<p>关键代码：部分-整体场景，树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p>
<p>示例代码：</p>
<p>文件节点：Filer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Filer &#123;</span><br><span class="line">    private $file_name;//文件名</span><br><span class="line">    </span><br><span class="line">    public function __construct($file_name)&#123;</span><br><span class="line">        $this-&gt;file_name = $file_name;</span><br><span class="line">    &#125;</span><br><span class="line">    //文件显示方法</span><br><span class="line">    public function display()&#123;</span><br><span class="line">        print_r($this-&gt;file_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目录节点：Noder<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Noder &#123;</span><br><span class="line">    private $node_name;//目录名</span><br><span class="line">    private $list = array(); //下级目录、文件列表</span><br><span class="line"></span><br><span class="line">    public function __construct($node_name)&#123;</span><br><span class="line">        $this-&gt;node_name = $node_name;</span><br><span class="line">    &#125;</span><br><span class="line">    //新增下级目录</span><br><span class="line">    public function addNoder(Noder $noder)&#123;</span><br><span class="line">        array_push($this-&gt;list, $noder);</span><br><span class="line">    &#125;</span><br><span class="line">    //新增文件</span><br><span class="line">    public function addFiler(Filer filer)&#123;</span><br><span class="line">        array_push($this-&gt;list, $filer);</span><br><span class="line">    &#125;</span><br><span class="line">    //显示下级目录及文件</span><br><span class="line">    public function display()&#123;</span><br><span class="line">        print_r($this-&gt;node_name);</span><br><span class="line">        foreach($this-&gt;list as $item)&#123;</span><br><span class="line">            $item.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类：Clienter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$noder = new Noder(&quot;home&quot;);</span><br><span class="line">$noder-&gt;addFilter(new Filer(&quot;fileA&quot;));</span><br><span class="line">$noder-&gt;addFilter(new Filer(&quot;fileB&quot;));</span><br><span class="line">$usr = new Noder(&quot;usr&quot;);</span><br><span class="line">$noder-&gt;addNoder($usr);</span><br><span class="line">$usr-&gt;addFiler(&quot;fileC&quot;);</span><br><span class="line">$noder-&gt;display();</span><br></pre></td></tr></table></figure></p>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>代理模式（Proxy）为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。</p>
<p>经典例子就是网络代理。</p>
<p>示例代码<br>主体类 Subject<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Subject &#123;</span><br><span class="line">    public function request() &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代理类 Proxy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Proxy &#123;</span><br><span class="line">    private static $subject;</span><br><span class="line">    public function request() &#123;</span><br><span class="line">        if (is_null(self::$subject)) &#123;</span><br><span class="line">            self::$subject = new Subject();</span><br><span class="line">        &#125;</span><br><span class="line">        $this-&gt;preRequest();</span><br><span class="line">        self::$subject-&gt;request();</span><br><span class="line">        $this-&gt;AfterRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    public function preRequest()&#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">    public function afterRequest()&#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类 Clienter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$proxy = new Proxy();</span><br><span class="line">$proxy-&gt;request();</span><br></pre></td></tr></table></figure></p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>运用共享技术有效地支持大量细粒度的对象。在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<p>享元模式是对象池模式的一种。</p>
<p><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。</p>
<p>在Java语言中，String类型就是使用了享元模式。String对象是final类型，对象一旦创建就不可改变。在JAVA中字符串常量都是存在常量池中的，Java会确保一个字符串常量在常量池中只有一个拷贝。譬如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;abc&quot;;</span><br><span class="line">String b = &quot;abc&quot;;</span><br><span class="line">System.out.println(a==b);</span><br></pre></td></tr></table></figure></p>
<p>a和b都指向了常量池中的同一个字符串常量“abc”。<br>享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的消耗。</p>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p>如何解决：将这些算法封装成一个一个的类，任意地替换。</p>
<p>注意：策略模式仅仅封装算法，但策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。将算法的责任和本身进行解耦。</p>
<p>优点：<br>1、算法可以自由切换。<br>2、避免使用多重条件判断。<br> 3、扩展性良好。</p>
<p>缺点：<br>1、策略类会增多。<br>2、客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</p>
<p>关键代码：实现同一个接口。</p>
<h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h5><p>策略接口：Strategy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Strategy &#123;</span><br><span class="line">    abstrasct function  discount($base_price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//会员打折</span><br><span class="line">class VipStrategy implements Strategy&#123;</span><br><span class="line">    public function discount($base_price) &#123;</span><br><span class="line">        return 0.88 * $base_price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//春节活动打折</span><br><span class="line">class SpringStrategy implements Strategy&#123;</span><br><span class="line">    public function discount($base_price) &#123;</span><br><span class="line">        return 0.9 * $base_price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//双11活动打折</span><br><span class="line">class EleventStrategy implements Strategy&#123;</span><br><span class="line">    public function discount($base_price) &#123;</span><br><span class="line">        return 0.7 * $base_price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>策略切换类：Context<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Context &#123;</span><br><span class="line">    private $strategy;</span><br><span class="line">    public function __construct(Strategy $strategy) &#123;</span><br><span class="line">        $this-&gt;strategy = $strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    public function discount($base_price)&#123;</span><br><span class="line">      return $this-&gt;strategy-&gt;discount($base_price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试：Clienter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$context = new Context(new EleventStrategy());</span><br><span class="line">$context-&gt;discount($base_price);</span><br><span class="line">$context = new Context(new VipStrategy());</span><br><span class="line">$context-&gt;discount($base_price);</span><br></pre></td></tr></table></figure></p>
<h5 id="策略模式和工厂方法模式的差别"><a href="#策略模式和工厂方法模式的差别" class="headerlink" title="策略模式和工厂方法模式的差别"></a>策略模式和工厂方法模式的差别</h5><ul>
<li><p>用途不一样<br>工厂是创建型模式,它的作用就是创建对象；<br>策略是行为型模式,它的作用是让一个对象在许多行为中选择一种行为</p>
</li>
<li><p>关注点不一样<br>一个关注对象（类型）创建<br>一个关注行为（算法）的封装</p>
</li>
<li><p>解决不同的问题<br>工厂模式是创建型的设计模式，它接受指令，创建出符合要求的实例；它主要解决的是资源的统一分发，将对象的创建完全独立出来，让对象的创建和具体的使用客户无关。主要应用在多数据库选择，类库文件加载等。<br>策略模式是为了解决的是策略的切换与扩展，更简洁的说是定义策略族，分别封装起来，让他们之间可以相互替换，策略模式让策略的变化独立于使用策略的客户。</p>
</li>
<li><p>工厂相当于黑盒子，策略相当于白盒子</p>
</li>
</ul>
<h4 id="模板模式（Template-Pattern）"><a href="#模板模式（Template-Pattern）" class="headerlink" title="模板模式（Template Pattern）"></a>模板模式（Template Pattern）</h4><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，即可重定义该算法的某些特定步骤。<br>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<p>模板方法模式将主要的方法定义为 final，防止子类修改算法骨架，将子类必须实现的方法定义为 abstract。而普通的方法（无 final 或 abstract 修饰）则称之为钩子（hook）。</p>
<p>关键代码：模板方法在抽象类实现，并加 final 关键词防重写，其他步骤在子类实现。</p>
<p>代码示例<br>模板抽象类：Template<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">abstract class Template &#123;</span><br><span class="line">    // 开锁</span><br><span class="line">   abstract unlock();</span><br><span class="line">    // 骑行</span><br><span class="line">   abstract ride();</span><br><span class="line">    // 上锁</span><br><span class="line">   abstract lock();</span><br><span class="line">    // 结算</span><br><span class="line">    abstract pay();</span><br><span class="line">    // 用户使用</span><br><span class="line">    public final use() &#123;</span><br><span class="line">        unlock();</span><br><span class="line">        ride();</span><br><span class="line">        lock();</span><br><span class="line">        pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 扫码开锁的单车</span><br><span class="line">class ScanBicycle extends Template &#123;</span><br><span class="line">    public function unlock() &#123;</span><br><span class="line">        //扫码开锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 密码开锁的单车</span><br><span class="line">class CodeBicycle extends Template &#123;</span><br><span class="line">    public function unlock() &#123;</span><br><span class="line">        //密码开锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="责任链模式（Chain-of-Responsibility-Pattern）"><a href="#责任链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="责任链模式（Chain of Responsibility Pattern）"></a>责任链模式（Chain of Responsibility Pattern）</h4><p>责任链模式将处理请求的对象连成一条链，沿着这条链传递该请求，直到有一个对象处理请求为止，这使得多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。</p>
<p>责任链模式在现实中使用的很多，常见的就是 OA 系统中的工作流、会员等级制度。</p>
<p>优点</p>
<ul>
<li>降低耦合度。它将请求的发送者和接收者解耦</li>
<li>容易扩展：增加新的处理类很方便，允许动态地新增或者删除责任。</li>
</ul>
<p>缺点</p>
<ul>
<li>不能保证请求一定被接收。</li>
<li>请求会从链头发出，直到有处理者响应，在责任链比较长的时候会影响系统性能。</li>
<li>可能不容易观察运行时的特征，有碍于除错。</li>
</ul>
<p>示例代码<br>需求等级按程序员-技术经理-cto 的顺序处理：</p>
<p>抽象处理者：Handler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">abstract class Handler &#123;</span><br><span class="line">    private $nextHandler;</span><br><span class="line">    private $level;</span><br><span class="line"></span><br><span class="line">    public function __construct($level) &#123;</span><br><span class="line">        $this-&gt;level = $level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理请求传递，注意final，子类不可重写</span><br><span class="line">    public final void handleMessage(Demand $demand) &#123;</span><br><span class="line">        if ($this-&gt;level == $demand-&gt;demandLevel()) &#123;</span><br><span class="line">            this-&gt;report($demand);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if ($this-&gt;nextHandler != null) &#123;</span><br><span class="line">                this-&gt;$nextHandler-&gt;handleMessage($demand);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                print_r(&quot;等级太高无法处理&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function setNextHandler(Handler $handler) &#123;</span><br><span class="line">        $this-&gt;nextHandler = $handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 抽象方法，子类实现</span><br><span class="line">    abstract function report(Demand $demand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体处理者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 技术经理</span><br><span class="line">class TechnicalManager extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void report(Demand $demand) &#123;</span><br><span class="line">        print_r(&quot;技术经理处理：&quot; + $demand-&gt;detail());       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// boss</span><br><span class="line">public class CTO extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void report(Demand $demand) &#123;</span><br><span class="line">        print_r(&quot;CTO处理：&quot; + $demand-&gt;detail());       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$demand = new Demand(); </span><br><span class="line">$cto = new CTO();</span><br><span class="line">$manager = new TechnicalManager();</span><br><span class="line">$manager-&gt;setNextHandler($cto); // 设置下一级</span><br><span class="line">$manager-&gt;handleMessage($demand);</span><br></pre></td></tr></table></figure></p>
<p>可以看到在客户端中的重点是设置下一级的处理者，这样多个处理者对象就会形成一条链。级别低的请求程序员自己处理，级别高的传递给了下一级的技术经理和cto。对于处理者本身是没有层级关系的，层级关系是由客户端来分配的。</p>
<h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<p>何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p>
<p>如何解决：构建语法树，定义终结符与非终结符。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>有一个简单的语法规则，比如一个sql语句，如果我们需要根据sql语句进行rm转换，就可以使用解释器模式来对语句进行解释。</p>
<p>一些重复发生的问题，比如加减乘除四则运算，但是公式每次都不同，有时是a+b-c<em>d，有时是a</em>b+c-d等，公式千变万化，但是都是由加减乘除四个非终结符来连接的，这时我们就可以使用解释器模式。</p>
<p>解释器模式在实际的系统开发中使用的很少，因为他会引起效率、性能以及维护等问题。</p>
<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p>迭代器模式（Iterator），又叫做游标（Cursor）模式。提供一种方法访问一个容器（Container）对象中各个元素，而又不需暴露该对象的内部细节。</p>
<p>当你需要访问一个聚合对象，而且不管这些对象是什么都需要遍历的时候，就应该考虑使用迭代器模式。另外，当需要对聚集有多种方式遍历时，可以考虑去使用迭代器模式。迭代器模式为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。</p>
<p>PHP标准库（SPL）中提供了迭代器接口 Iterator，要实现迭代器模式，实现该接口即可。</p>
<p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class String implements Iterator &#123;</span><br><span class="line">    private $string;</span><br><span class="line">    public function __construct($string)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;string = $this-&gt;strToArray($string);</span><br><span class="line">    &#125;</span><br><span class="line">    private function strToArray($string,$l=0) &#123;</span><br><span class="line">        if ($l &gt; 0) &#123;</span><br><span class="line">            $ret = array();</span><br><span class="line">            $len = mb_strlen($string, &quot;UTF-8&quot;);</span><br><span class="line">            for ($i = 0; $i &lt; $len; $i += $l) &#123;</span><br><span class="line">                $ret[] = mb_substr($string, $i, $l, &quot;UTF-8&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return $ret;</span><br><span class="line">        &#125;</span><br><span class="line">        return preg_split(&quot;//u&quot;, $string, -1, PREG_SPLIT_NO_EMPTY);</span><br><span class="line">    &#125;</span><br><span class="line">    public function current()</span><br><span class="line">    &#123;</span><br><span class="line">        return current($this-&gt;string);</span><br><span class="line">    &#125;</span><br><span class="line">    public function next()</span><br><span class="line">    &#123;</span><br><span class="line">        return next($this-&gt;string);</span><br><span class="line">    &#125;</span><br><span class="line">    public function key()</span><br><span class="line">    &#123;</span><br><span class="line">        key($this-&gt;string);</span><br><span class="line">    &#125;</span><br><span class="line">    public function valid()</span><br><span class="line">    &#123;</span><br><span class="line">        if(key($this-&gt;string) === null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public function rewind()</span><br><span class="line">    &#123;</span><br><span class="line">        reset($this-&gt;string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//client</span><br><span class="line">$string = new String(&apos;这个是什么213jdjlf&apos;);</span><br><span class="line"></span><br><span class="line">foreach ($string as $k =&gt; $v) &#123;</span><br><span class="line">    echo $v.&quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个设计模式实际业务会很少用到，在定义自己的数据类型时可能会用到， PHP里面的数组已经很逆天了，基本不需要搞自己的数据类型。</p>
<h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p>用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示的相互作用，从而使耦合松散，而且可以独立的改变他们之间的交互.</p>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ul>
<li>抽象中介者类（AbstractMediator）.</li>
<li>具体中介者实现类（Mediator）.</li>
<li>同事类（Colleague）：每一个同事角色都知道中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2281730-28d62c4a3b0208c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><p>1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。<br>2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>各个同事类之间的解耦.</li>
<li>降低类的复杂度.</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>同事类过多会使中介者庞大，难以维护.</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>抽象中介者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">abstract class Mediator &#123;</span><br><span class="line">       //定义同事类</span><br><span class="line">       private $colleagueA;</span><br><span class="line">       private $colleagueB;</span><br><span class="line"></span><br><span class="line">       public function setColleagueA(Colleague $colleagueA) &#123;</span><br><span class="line">           $this-&gt;colleagueA = $colleagueA;</span><br><span class="line">       &#125;</span><br><span class="line">       public function setColleagueB(Colleague $colleagueB) &#123;</span><br><span class="line">           $this-&gt;colleagueB = $colleagueB;</span><br><span class="line">       &#125;</span><br><span class="line">       public abstract function doSomething1();</span><br><span class="line">       public abstract function doSomething2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体中介者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ConcreteMediator extends Mediator&#123;</span><br><span class="line"></span><br><span class="line">    public function doSomething1() &#123;</span><br><span class="line">        //调用同事类的方法</span><br><span class="line">        $this-&gt;colleagueA-&gt;selfMethod1();</span><br><span class="line">        $this-&gt;colleagueB-&gt;selfMethod2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function doSomething2() &#123;</span><br><span class="line">        $this-&gt;colleagueA-&gt;selfMethod2();</span><br><span class="line">        $this-&gt;colleagueB-&gt;selfMethod1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抽象同事类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract class Colleague &#123;</span><br><span class="line">    protected $mediator;</span><br><span class="line">    public function __construct(Mediator $mediator) &#123;</span><br><span class="line">        $this-&gt;mediator = $mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体同事类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ConcreteColleague  extends Colleague &#123;</span><br><span class="line">    //自有方法</span><br><span class="line">    public function selfMethod(): void &#123;</span><br><span class="line">        //处理自己能处理的逻辑</span><br><span class="line">    &#125;</span><br><span class="line">    //依赖方法</span><br><span class="line">    public function depMethod1() &#123;</span><br><span class="line">        //处理自己能处理的逻辑</span><br><span class="line">        //自己不能处理的业务逻辑，委托给中介者</span><br><span class="line">        $this-&gt;mediator-&gt;doSomething1();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>观察者模式有时也被称作发布/订阅模式，该模式用于为对象实现发布/订阅功能：一旦主体对象状态发生改变，与之关联的观察者对象会收到通知，并进行相应操作。</p>
<p>将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。</p>
<p>消息队列系统、事件都使用了观察者模式。</p>
<p>业务场景：</p>
<p> 哈票以购票为核心业务(此模式不限于该业务)，但围绕购票会产生不同的其他逻辑，如：<br>1、购票后记录文本日志<br>2、购票后记录数据库日志<br>3、购票后发送短信<br>4、购票送抵扣卷、兑换卷、积分<br>5、其他各类活动等</p>
<p>传统解决方案:<br>在购票逻辑等类内部增加相关代码，完成各种逻辑。</p>
<p>观察者模式典型实现方式：<br> 1、定义2个接口：观察者（通知）接口、被观察者（主题）接口<br> 2、定义2个类，观察者对象实现观察者接口、主题类实现被观者接口<br>3、主题类注册自己需要通知的观察者<br>4、主题类某个业务逻辑发生时通知观察者对象，每个观察者执行自己的业务逻辑。</p>
<p>示例代码：<br>观察者接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface TicketObserver &#123;</span><br><span class="line">     //得到通知后调用的方法</span><br><span class="line">     public function onBuyTicketOver($sender, $args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>被观察者接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface TicketObservable &#123;</span><br><span class="line">    //提供注册观察者方法</span><br><span class="line">    public function addObserver($observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>观察者:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//短信通知</span><br><span class="line">class MSM implements ITicketObserver &#123;</span><br><span class="line">    public function onBuyTicketOver($sender, $ticket) &#123;</span><br><span class="line">        echo &quot;短信通知&quot;；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//push通知</span><br><span class="line">class Push implements ITicketObserver &#123;</span><br><span class="line">    public function onBuyTicketOver($sender, $ticket) &#123;</span><br><span class="line">        echo &quot;push通知&quot;；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>被观察者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Ticket implements TicketObservable &#123;</span><br><span class="line">    private $_comsumer;</span><br><span class="line">    private $_observers = array (); //观察者</span><br><span class="line">    //购票流程</span><br><span class="line">    public function buyTicket($ticket) &#123;</span><br><span class="line">       // TODO 购票逻辑</span><br><span class="line">       //循环通知，调用其onBuyTicketOver实现不同业务逻辑</span><br><span class="line">       foreach ( $this-&gt;_observers as $obs )</span><br><span class="line">           $obs-&gt;onBuyTicketOver ( $this-&gt;_comsumer, $ticket );</span><br><span class="line">    &#125;</span><br><span class="line">     //添加通知</span><br><span class="line">    public function addObserver($observer) &#123;</span><br><span class="line">       $this-&gt;_observers [] = $observer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="http://link.hhtjim.com/163/5146554.mp3"></li>
                    
                        <li title="1" data-url="http://link.hhtjim.com/qq/001faIUs4M2zna.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="" data-cs="" data-r="" data-o="" data-a="" data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
